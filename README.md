# EvilWfshbr

[CVE-2022-42046](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-42046) Proof of Concept of wfshbr64.sys local privilege escalation

wfshbr64.sys and wfshbr32.sys specially crafted payload allows arbitrary user to perform bitwise operation with arbitrary EPROCESS offset and flags value to purposely elevate the game process to CodeGen Full protection by manipulating `EPROCESS.Protection` and `EPROCESS.SignatureLevel` flags (security hole as a feature).

The driver is signed by Microsoft hardware compatibility publisher that is submitted via Microsoft Hardware Program.

This project was co-researched with [@DoranekoSystems](https://github.com/DoranekoSystems)

# License

MIT. See [LICENSE](LICENSE)

# Suggestion (For Developer)

1. Use [`ObRegisterCallbacks`](https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-obregistercallbacks) instead of forcefully elevating process protection by performing direct kernel object manipulation. There is a good example in [here](https://github.com/microsoft/Windows-driver-samples/tree/main/general/obcallback).

## 2. IRP

Do not reference IRP after completion. if you have driver verifier enabled you will get caught.

```cpp
IofCompleteRequest(Irp, IO_NO_INCREMENT); // IRP is freed here
return Irp->IoStatus.Status;
```

Instead you should use local variable.

```cpp
NTSTATUS status = STATUS_SUCCESS;
Irp->IoStatus.Status = status;
IofCompleteRequest(Irp, IO_NO_INCREMENT); // IRP is freed here
return status;
```

## 3. Context Process

It looks like you're checking null pointer against return value of `IoGetCurrentProcess`, but it never return null pointer by design so you do not have to check it.

```cpp
PEPROCESS CurrentProcess = IoGetCurrentProcess();
  if ( !CurrentProcess ) // no need to check for null pointer
    break;
```

# The Trick

A while after the report, the developer implemented sneaky "additional verification" to defeat our first PoC instead of stepping down from making security holes as a feature.

Checks added to:

- `IOCTL_WFSHBR_REMOVE_FLAG`
- `IOCTL_WFSHBR_ADD_FLAG`
- `IOCTL_WFSHBR_AND_FLAG`

```diff
case IOCTL_WFSHBR_ADD_FLAG: // 0xAA013884
      if ( !KwfsVerifyCaller(Buffer) ) // verify caller
        break;
-     if ( Buffer->ArbitraryEProcessOffset >= 0x1000 ) // offset limitation check
+     if ( !KwfsVerifyOffsetAndFlags(Buffer->ArbitraryEProcessOffset,
+                                    Buffer->DesiredFlags) ) // verify the offset and flags
        break;
      *(ULONG*)(IoGetCurrentProcess() + Buffer->ArbitraryEProcessOffset) |= Buffer->DesiredFlags;
```

## KwfsVerifyOffsetAndFlags

This routine is designed to be called every time the client requests modification of EPROCESS, and performs verification of `Offset` provided by `ArbitraryEProcessOffset` field in this PoC â€• and also `Flags` provided by `DesiredFlags` field in this PoC.

The verification is quite simple as it counts `1` bits in every bits field of provided flags and if the count greater than eight it will fail.

Possible flags pattern map is just four:

- `22 00 00 00`
- `00 22 00 00`
- `00 00 22 00`
- `00 00 00 22`

That said, performing following operations 4 times can guarantee that the at least one of attempt should be successfull:

- Subtract the `ArbitraryEProcessOffset` field by index: `offset - index`,
- And adjust bits in `DesiredFlags` field by index: `flag << (index * 8)`.

We have added `WfsProtectProcessSupreme` and `WfsUnprotectProcessSupreme` functions which performs the attempt and defeated the new trick.

```cpp
enum KwfsState {
  KwfsStateOnceCall = 0,
  KwfsStateNeedsValueEquality = 1,
  KwfsStateValueHasBeenSet = 2,
};

BOOLEAN KwfsVerifyOffsetAndFlags(_In_ ULONG Offset, _In_ ULONG Flags) {
  // KwfsState::KwfsStateNeedsValueEquality
  if (g_KwfsVerifyState != KwfsState::KwfsStateValueHasBeenSet
   && Offset == g_KwfsVerifyStateOffset
   && Flags == g_KwfsVerifyStateFlags) {
    return TRUE;
  }

  if (Offset < 0x1000) { // offset limitation check moved here
    int counter = 0;
    for (int i = 0; i < 0x20; i++) {
      if ((Flags >> (i & 0x1F) & 1) != 0) { // _bittest is simpler too
        counter++;
      }
    }

    if (counter <= 8) {
      g_KwfsVerifyState = KwfsState::KwfsStateNeedsValueEquality;
      g_KwfsVerifyStateOffset = Offset;
      g_KwfsVerifyStateFlags = Flags;
      return TRUE;
    }
  }

  return FALSE;
}
```
